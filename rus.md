# Как предотвратить снижение производительности при использовании подключаемых 
шрифтов

На повестке дня: 1) подключаемые шрифты шикарны и мы хотим их использовать 2) 
подключаемые шрифты - это большие дополнительные ресурсы, которые замедляют 
загрузку страниц. В последнее время все активно занимаются поиском оптимального 
решения для использования подключаемых шрифтов и я решил подготовить сводку 
некоторых соображений по этому поводу и добавить свои. 

## Загрузка только для больших экранов

Первым на глаза мне попалось исследование Дейва Руперта (Dave Rupert) по 
загрузке @font-face только для больших экранов. Получается что если вы 
используете @font-face, но не применяете прописанную в нем гарнитуру, шрифт 
закачиваться не будет. Довольно умно для браузеров. [Демо Дейва][1].

**CSS**

    @font-face {
      font-family: 'Dr Sugiyama';
      font-style: normal;
      font-weight: 400;
      src: local("Dr Sugiyama Regular"), local("DrSugiyama-Regular"), url(http://themes.googleusercontent.com/static/fonts/drsugiyama/v2/rq_8251Ifx6dE1Mq7bUM6brIa-7acMAeDBVuclsi6Gc.woff) format("woff");
    }

    body {
      font-family: sans-serif;
    }
    @media (min-width: 1000px) {
      body {
        font-family: 'Dr Sugiyama', sans-serif;
      }
    }

В своей статье [«Резервные шрифты для мобильных устройств»][2] в блоге Typekit 
Джордан Мур (Jordan Moore) предлагает похожий подход.

> Я применил такой подход в собственном проекте и подготовил два набора шрифтов: 
«полный» набор, содержащий все типографические стили которые я изначально 
собирался использовать, и «облегченный» набор, состоящий из меньшего количества 
шрифтов (и, соответственно, с существенно меньшим весом). С помощью JavaScript я 
настроил подключение одного из них в зависимости от ширины экрана, исходя из 
значения наименьшей ключевой точки. 

Используя прием Дейва, вам не нужно волноваться по поводу возможных проблесков 
нестилизированого текста, так как в нем используется @font-face, который 
является родным для CSS и в большинстве браузеров эта проблема решена. Как мне 
кажется, приём Джордана оставляет большую вероятность для эфекта проблеска 
нестилизированого текста, так как шрифт грузится после проверки; это однако 
можно исправить как обычно исправляются проблемы для Typekit: [применив 
`visibility: hidden` пока шрифт не полностью загружен][3]. 

## Ajax для шрифтов

Если больше всего вас беспокоит увеличение задержки отображения (не обязательно 
до полной загрузки страницы), можете использовать Ajax для таблицы стилей, 
которая содержит @font-face, когда документ готов. Омар Аль Замир (Omar Al 
Zabir) [создал урок о том как это делается][4]. (спасибо [Кевину][5])

**JavaScript**

    $(document).ready(function(){
      $.ajax({
        url: fontFile,
        beforeSend: function ( xhr ) {
          xhr.overrideMimeType("application/octet-stream");
        },
        success: function(data) {
          $("<link />", {
            'rel': 'stylesheet'
            'href': 'URL/TO/fonts.css'
          }).appendTo('head');
        }
      });
    });

Также важно убедиться что у файлов долговечные названия. Чтобы предотвратить 
эфект проблеска нестилизированого текста, нужно присвоить класс элементу `<html>` 
(непосредственно через JavaScript) и использовать его для того чтобы скрыть с 
помощью `visibility: hidden` все что нужно скрыть пока загружаются шрифты, а 
затем удалить его в Ajax функции обратного вызова success. 

## Загрузка шрифтов по требованию, загрузка при последующих загрузках страницы 
после кеширования

Если продолжить развивать эту идею, можно было бы отображать подключённые шрифты 
только тогда когда мы точно знаем что файлы шрифтов кешируются. На стороне 
сервера мы проверяем наличие cookie (который мы сами установим позже), что 
подтверждает кеширование шрифтов. 

**PHP**

    // Проверяем наличие cookie, предполагая что шрифты были закешированы

    if (fonts_are_cached) {
      echo "<link rel='stylesheet' href='/URL/TO/fonts.css'>";
    }

С клиентской стороны мы делаем противоположное. Если cookie отсутствует, мы 
загружаем шрифты по требованию и затем добавляем cookie. 

**JavaScript**

    // Проверяем наличие cookie, предполагая что шрифты были закешированы

    if (!fonts_are_cached) {

      // Не замедляем отрисовку
      $(window).load(function() {

        // Загружаем шрифты
        $.ajax({
          url: 'URL/TO/font.woff'
        });
        $.ajax({
          url: 'URL/TO/font.eot'
        });
        // По сути ничего с ними не делаем, просто запрашиваем их чтобы они были добавлены в кеш 

        // Добавляем cookie, которое указывает на то что шрифты закешированы 

      });
  
    }

Ошибки не исключены, так как cookie не является стопроцентной гарантией того, 
что шрифт добавлен в кеш. Но если задать ему срок действия например 
продолжительностью в один день, шансы неплохие. Проблеска нестилизированного 
текста здесь не будет, так как или шрифты не грузятся вообще, или грузятся 
естественным образом с помощью @font-face. Если вы ничего не имеете против 
проблеска нестилизированого текста (т.е. если вы хотите чтобы подключенные 
шрифты отображались при первой загрузке страницы несмотря ни на что), можете 
создать `<link>` и вставить таблицу стилей со шрифтами вместо простого запроса 
шрифта. 

Еще одним вариантом будет помещение data URI версии шрифта в локальное хранилище 
и вызов его при необходимости. Следует создать элемент `<style>`, поместить в 
него код @font-face, используя data URI версию шрифта, и подключить его. По всей 
видимости в The Guardian пробуют так сделать.

> @tkadlec @davatron5000 @chriscoyier ...Дайте мне знать если заметите ошибки. 
Пока вроде работает хорошо, хоть это и не лучший вариант. -  Scott Jehl @scottjehl

> @scottjehl По теме кеша: the Guardian экспериментирует с localStorage. https://github.com/guardian/frontend/blob/master/common/app/assets/javascripts/modules/fonts.js#L88 … @davatron5000 @chriscoyier -  Tim Kadlec @tkadlec

Верно подмечено, localStorage может быть более медленным чем кеширование.

> @scottjehl По теме кеша: the Guardian экспериментирует с localStorage. https://github.com/guardian/frontend/blob/master/common/app/assets/javascripts/modules/fonts.js#L88 … @davatron5000 @chriscoyier -  Tim Kadlec @tkadlec

> @tkadlec @scottjehl @davatron5000 @chriscoyier вариант с локальным хранилищем 
работает, если оно вам совсем уж необходимо, но оно может читаться медленнее чем 
кеш браузера.

Возможное преимущество использования примочек JavaScript - это осведомленность 
какие версии шрифтов вам нужны.

> @StuRobson @chriscoyier Не знаю. @scottjehl, кешируется хорошо? -  Dave Rupert 
@davatron5000

> @davatron5000 @StuRobson @chriscoyier мы подгружаем шрифты в data uri с 
помощью insertBefore. По умолчанию WOFF.css, на android/ie используются TTF или 
EOT. -  Scott Jehl @scottjehl

[И как][6]

## Перспективы

Чем больше информации у нас есть о пользователях, тем лучше. 

Какие у них пропускная способность и латентность? Их довольно сложно определить 
и результаты не слишком надежны даже когда это возможно. Возможно в один 
прекрасный день [API сетевой информации][7] прояснит ситуацию. 

Какой у них размер экрана? Какими возможностями обладает их браузер? Это можно 
определить с помощью JavaScript, но что если хорошо бы их было определять на 
серверной стороне? Возможно в один прекрасный день [Client-Hints][8] прояснит 
ситуацию.

[1]: http://codepen.io/davatron5000/pen/nrfGA
[2]: http://blog.typekit.com/2013/04/17/fallback-fonts-on-mobile-devices/
[3]: http://blog.typekit.com/2010/10/29/font-events-controlling-the-fout/
[4]: http://www.codeproject.com/Articles/462209/Using-custom-font-without-slowing-down-page-load
[5]: https://twitter.com/ilikevests/status/324593491411873792
[6]: https://gist.github.com/scottjehl/5406853
[7]: http://www.w3.org/TR/netinfo-api/#the-networkinformation-interface
[8]: https://github.com/igrigorik/http-client-hints
